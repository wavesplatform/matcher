//package com.wavesplatform.dex.matching
//
//import akka.actor.{ActorRef, Props}
//import akka.pattern.ask
//import akka.testkit.TestProbe
//import com.wavesplatform.dex.MatcherSpecBase
//import com.wavesplatform.dex.actors.MatcherSpecLike
//import com.wavesplatform.dex.actors.address.AddressActor.BlockchainInteraction
//import com.wavesplatform.dex.actors.address.AddressActor.Command.PlaceOrder
//import com.wavesplatform.dex.actors.address.AddressDirectoryActor.Command.ForwardMessage
//import com.wavesplatform.dex.actors.address.{AddressActor, AddressDirectoryActor}
//import com.wavesplatform.dex.db.{EmptyOrderDb, TestOrderDb, WithDb}
//import com.wavesplatform.dex.domain.account.{Address, PublicKey}
//import com.wavesplatform.dex.domain.asset.Asset.Waves
//import com.wavesplatform.dex.domain.asset.{Asset, AssetPair}
//import com.wavesplatform.dex.domain.order.OrderType.{BUY, SELL}
//import com.wavesplatform.dex.domain.order.{Order, OrderType}
//import com.wavesplatform.dex.grpc.integration.clients.domain.AddressBalanceUpdates
//import com.wavesplatform.dex.grpc.integration.dto.BriefAssetDescription
//import com.wavesplatform.dex.model.Events.{OrderAdded, OrderAddedReason, OrderCanceled, OrderExecuted}
//import com.wavesplatform.dex.model.{Events, LimitOrder, MarketOrder, OrderValidator}
//import com.wavesplatform.dex.queue.{ValidatedCommand, ValidatedCommandWithMeta}
//import org.scalatest.prop.TableDrivenPropertyChecks
//import org.scalatest.propspec.AnyPropSpecLike
//
//import scala.concurrent.duration.Duration
//import scala.concurrent.{Await, Future}
//import scala.math.BigDecimal.RoundingMode.CEILING
//import scala.util.Success
//
///**
// * Tests for reserved balance
// *
// * This specification checks how different cases affect reserved balance.
// *
// * Test cases was generated by filtered decision table:
// *
// * Field Name          | Values                          | Description
// * -------------------------------------------------------------------
// * CounterType         | Buy, Sell                       | Submitted type will be set automatically
// * Amounts             | A_c = A_s, A_c > A_s, A_c < A_s | A_c - counter amount, A_s - submitted amount
// * CorrectedAmount     | A_corr = A, A_corr < A          | A - match amount
// * Prices              | P_c = P_s, P_c != P_s           | P_c - counter price, P_s - submitted price
// * CounterRestAmount   | 0, A_min, A_min - 1             | Rest amount after matching. A_min - minimal amount can be filled by the price
// * SubmittedRestAmount | 0, A_min, A_min - 1             | Rest amount after matching. A_min - minimal amount can be filled by the price
// *
// * CounterType | Amounts   | CorrectedAmount | Prices     | CounterRestAmount | SubmittedRestAmount
// * ------------------------------------------------------------------------------------------------
// * Buy         | A_c = A_s | A_corr = A      | P_c = P_s  | 0                 | 0
// * Sell        | A_c = A_s | A_corr = A      | P_c = P_s  | 0                 | 0
// * Buy         | A_c = A_s | A_corr = A      | P_c != P_s | 0                 | 0
// * Sell        | A_c = A_s | A_corr = A      | P_c != P_s | 0                 | 0
// * Buy         | A_c > A_s | A_corr = A      | P_c = P_s  | A_min - 1         | 0
// * Sell        | A_c > A_s | A_corr = A      | P_c = P_s  | A_min - 1         | 0
// * Buy         | A_c > A_s | A_corr = A      | P_c != P_s | A_min - 1         | 0
// * Sell        | A_c > A_s | A_corr = A      | P_c != P_s | A_min - 1         | 0
// * Buy         | A_c < A_s | A_corr = A      | P_c = P_s  | 0                 | A_min - 1
// * Sell        | A_c < A_s | A_corr = A      | P_c = P_s  | 0                 | A_min - 1
// * Buy         | A_c < A_s | A_corr = A      | P_c != P_s | 0                 | A_min - 1
// * Sell        | A_c < A_s | A_corr = A      | P_c != P_s | 0                 | A_min - 1
// * Buy         | A_c > A_s | A_corr = A      | P_c = P_s  | A_min             | 0
// * Sell        | A_c > A_s | A_corr = A      | P_c = P_s  | A_min             | 0
// * Buy         | A_c > A_s | A_corr = A      | P_c != P_s | A_min             | 0
// * Sell        | A_c > A_s | A_corr = A      | P_c != P_s | A_min             | 0
// * Buy         | A_c < A_s | A_corr = A      | P_c = P_s  | 0                 | A_min
// * Sell        | A_c < A_s | A_corr = A      | P_c = P_s  | 0                 | A_min
// * Buy         | A_c < A_s | A_corr = A      | P_c != P_s | 0                 | A_min
// * Sell        | A_c < A_s | A_corr = A      | P_c != P_s | 0                 | A_min
// * Buy         | A_c = A_s | A_corr < A      | P_c = P_s  | A_min - 1         | A_min - 1
// * Sell        | A_c = A_s | A_corr < A      | P_c = P_s  | A_min - 1         | A_min - 1
// * Buy         | A_c < A_s | A_corr < A      | P_c = P_s  | A_min - 1         | A_min
// * Sell        | A_c < A_s | A_corr < A      | P_c = P_s  | A_min - 1         | A_min
// * Buy         | A_c > A_s | A_corr < A      | P_c = P_s  | A_min             | A_min - 1
// * Sell        | A_c > A_s | A_corr < A      | P_c = P_s  | A_min             | A_min - 1
// */
//class ReservedBalanceSpecification extends AnyPropSpecLike with MatcherSpecLike with WithDb with MatcherSpecBase with TableDrivenPropertyChecks {
//
//  import system.dispatcher
//
//  private val pair: AssetPair = AssetPair(mkAssetId("WAVES"), mkAssetId("USD"))
//
//  private val addressDir = system.actorOf(
//    Props(
//      new AddressDirectoryActor(
//        EmptyOrderDb(),
//        createAddressActor,
//        recovered = true
//      )
//    )
//  )
//
//  private val emptyAddressBalanceUpdatesF = Future.successful(AddressBalanceUpdates.empty)
//
//  private val blockchainInteraction = new BlockchainInteraction {
//    override def getFullBalances(address: Address, exclude: Set[Asset]): Future[AddressBalanceUpdates] = emptyAddressBalanceUpdatesF
//  }
//
//  private def assetBriefInfo: Asset => BriefAssetDescription =
//    asset => BriefAssetDescription(asset.toString, 2, hasScript = false, isNft = false)
//
//  private def createAddressActor(address: Address, recovered: Boolean): Props =
//    AddressActor.props(
//      address,
//      time,
//      TestOrderDb(100),
//      (_, _) => Future.successful(Right(())),
//      _ => Future.failed(new IllegalStateException("Should not be used in the test")),
//      recovered,
//      blockchainInteraction,
//      getAssetDescription = assetBriefInfo
//    )
//
//  private def minAmountFor(price: Long, amountDecimals: Int = 8): Long = { BigDecimal(Math.pow(10, amountDecimals)) / BigDecimal(price) }
//    .setScale(0, CEILING)
//    .toLong
//
//  private def openVolume(senderPublicKey: PublicKey, assetId: Asset, addressDirectory: ActorRef = addressDir): Long =
//    Await
//      .result(
//        (addressDirectory ? AddressDirectoryActor.Command.ForwardMessage(senderPublicKey, AddressActor.Query.GetReservedBalance))
//          .mapTo[AddressActor.Reply.GetBalance].map(_.balance),
//        Duration.Inf
//      )
//      .getOrElse(assetId, 0L)
//
//  def execute(counter: Order, submitted: Order): OrderExecuted = {
//    val now = time.getTimestamp()
//
//    addressDir ! AddressActor.Command.ApplyOrderBookAdded(OrderAdded(LimitOrder(counter, None, None), OrderAddedReason.RequestExecuted, now))
//    addressDir ! AddressActor.Command.ApplyOrderBookAdded(OrderAdded(LimitOrder(submitted, None, None), OrderAddedReason.RequestExecuted, now))
//    val exec = OrderExecuted(
//      LimitOrder(submitted, None, None),
//      LimitOrder(counter, None, None),
//      submitted.timestamp,
//      counter.matcherFee,
//      submitted.matcherFee,
//      0L
//    )
//    addressDir ! AddressActor.Command.ApplyOrderBookExecuted(AddressActor.OrderBookExecutedEvent(
//      exec,
//      mkExchangeTx(exec)
//    ))
//    exec
//  }
//
//  forAll(
//    Table(
//      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
//      (BUY, 2.waves, 2.3.usd, 2.waves, 2.3.usd),
//      (SELL, 2.waves, 2.3.usd, 2.waves, 2.3.usd),
//      (BUY, 2.waves, 2.3.usd, 2.waves, 2.2.usd),
//      (SELL, 2.waves, 2.2.usd, 2.waves, 2.3.usd)
//    )
//  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
//    property(s"Reserves should be 0 when remains are 0: $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice") {
//      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
//      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
//      initAddressesOf(counter, submitted)
//      val exec = execute(counter, submitted)
//
//      withClue("Both orders should be filled") {
//        exec.executedAmount shouldBe counter.amount
//      }
//
//      withClue("All remains should be 0") {
//        exec.counterRemainingAmount shouldBe 0
//        exec.submittedRemainingAmount shouldBe 0
//      }
//
//      withClue(s"Counter sender should not have reserves") {
//        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
//        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
//      }
//
//      withClue(s"Submitted sender should not have reserves") {
//        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
//        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
//      }
//    }
//  }
//
//  forAll(
//    Table(
//      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
//      (BUY, 2.00434782.waves, 2.3.usd, 2.waves, 2.3.usd),
//      (SELL, 2.00434782.waves, 2.3.usd, 2.waves, 2.3.usd),
//      (BUY, 2.00434782.waves, 2.3.usd, 2.waves, 2.2.usd),
//      (SELL, 2.00454545.waves, 2.2.usd, 2.waves, 2.3.usd)
//    )
//  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
//    property(
//      s"Counter reserves should be 0 WHEN remain is (minAmount - 1): $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
//    ) {
//      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
//      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
//      initAddressesOf(counter, submitted)
//      val exec = execute(counter, submitted)
//
//      withClue("Both orders should be filled") {
//        exec.executedAmount shouldBe submittedAmount
//      }
//
//      withClue("Counter remain should be (minAmount - 1):") {
//        exec.counterRemainingAmount shouldBe minAmountFor(counterPrice) - 1
//        exec.submittedRemainingAmount shouldBe 0
//      }
//
//      withClue(s"Counter sender should not have reserves:") {
//        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
//        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
//      }
//
//      withClue(s"Submitted sender should not have reserves:") {
//        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
//        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
//      }
//    }
//  }
//
//  forAll(
//    Table(
//      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
//      (BUY, 2.waves, 2.3.usd, 2.00434782.waves, 2.3.usd),
//      (SELL, 2.waves, 2.3.usd, 2.00434782.waves, 2.3.usd),
//      (BUY, 2.waves, 2.3.usd, 2.00454545.waves, 2.2.usd),
//      (SELL, 2.waves, 2.2.usd, 2.00434782.waves, 2.3.usd)
//    )
//  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
//    property(
//      s"Submitted reserves should be 0 WHEN remain is (minAmount - 1): $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
//    ) {
//      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
//      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
//      initAddressesOf(counter, submitted)
//      val exec = execute(counter, submitted)
//
//      withClue("Both orders should be filled") {
//        exec.executedAmount shouldBe counterAmount
//      }
//
//      withClue("Submitted remain should be (minAmount - 1):") {
//        exec.counterRemainingAmount shouldBe 0
//        exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice) - 1
//      }
//
//      withClue(s"Counter sender should not have reserves:") {
//        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
//        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
//      }
//
//      withClue(s"Submitted sender should not have reserves:") {
//        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
//        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
//      }
//    }
//  }
//
//  forAll(
//    Table(
//      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
//      (BUY, 2.00434783.waves, 2.3.usd, 2.waves, 2.3.usd),
//      (SELL, 2.00434783.waves, 2.3.usd, 2.waves, 2.3.usd),
//      (BUY, 2.00434783.waves, 2.3.usd, 2.waves, 2.2.usd),
//      (SELL, 2.00454546.waves, 2.2.usd, 2.waves, 2.3.usd)
//    )
//  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
//    property(
//      s"Counter reserve should be minAmount WHEN remain is minAmount: $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
//    ) {
//      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
//      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
//      initAddressesOf(counter, submitted)
//      val exec = execute(counter, submitted)
//
//      withClue("Counter should be partially filled:") {
//        exec.executedAmount shouldBe submittedAmount
//      }
//
//      withClue("Counter remain should be minAmount:") {
//        exec.counterRemainingAmount shouldBe minAmountFor(counterPrice)
//        exec.submittedRemainingAmount shouldBe 0
//      }
//
//      withClue(s"Counter sender should have reserved asset:") {
//        val (expectedAmountReserve, expectedPriceReserve) = if (counterType == BUY) (0, 1) else (minAmountFor(counterPrice), 0)
//        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe expectedAmountReserve
//        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe expectedPriceReserve
//      }
//
//      withClue(s"Submitted sender should not have reserves:") {
//        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
//        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
//      }
//    }
//  }
//
//  forAll(
//    Table(
//      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
//      (BUY, 2.waves, 2.3.usd, 2.00434783.waves, 2.3.usd),
//      (SELL, 2.waves, 2.3.usd, 2.00434783.waves, 2.3.usd),
//      (BUY, 2.waves, 2.3.usd, 2.00454546.waves, 2.2.usd),
//      (SELL, 2.waves, 2.2.usd, 2.00434783.waves, 2.3.usd)
//    )
//  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
//    property(
//      s"Submitted reserve should be minAmount WHEN remain is minAmount: $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
//    ) {
//      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
//      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
//      initAddressesOf(counter, submitted)
//      val exec = execute(counter, submitted)
//
//      withClue("Submitted should be partially filled:") {
//        exec.executedAmount shouldBe counterAmount
//      }
//
//      withClue("Submitted remain should be minAmount:") {
//        exec.counterRemainingAmount shouldBe 0
//        exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice)
//      }
//
//      withClue(s"Counter sender should not have reserves:") {
//        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
//        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
//      }
//
//      withClue(s"Submitted sender should have reserved asset:") {
//        val (expectedAmountReserve, expectedPriceReserve) = if (counterType == BUY) (minAmountFor(submittedPrice), 0) else (0, 1)
//        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe expectedAmountReserve
//        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe expectedPriceReserve
//      }
//    }
//  }
//
//  forAll(
//    Table(
//      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
//      (BUY, 2.00434782.waves, 2.3.usd, 2.00434782.waves, 2.3.usd),
//      (SELL, 2.00434782.waves, 2.3.usd, 2.00434782.waves, 2.3.usd)
//    )
//  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
//    property(
//      s"Counter and submitted reserves should be 0 WHEN both remains are (minAmount - 1): $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
//    ) {
//      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
//      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
//      initAddressesOf(counter, submitted)
//      val exec = execute(counter, submitted)
//
//      exec.executedAmount shouldBe 2.waves
//
//      exec.counterRemainingAmount shouldBe minAmountFor(counterPrice) - 1
//      exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice) - 1
//
//      withClue(s"Counter sender should not have reserves:") {
//        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
//        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
//      }
//
//      withClue(s"Submitted sender should not have reserves:") {
//        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
//        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
//      }
//    }
//  }
//
//  forAll(
//    Table(
//      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
//      (BUY, 2.00434782.waves, 2.3.usd, 2.00434783.waves, 2.3.usd),
//      (SELL, 2.00434782.waves, 2.3.usd, 2.00434783.waves, 2.3.usd)
//    )
//  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
//    property(
//      s"Counter and submitted reserves should be 0 and minAmount WHEN their remains are (minAmount - 1) and minAmount: $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
//    ) {
//      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
//      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
//      initAddressesOf(counter, submitted)
//      val exec = execute(counter, submitted)
//
//      exec.executedAmount shouldBe 2.waves
//
//      exec.counterRemainingAmount shouldBe minAmountFor(counterPrice) - 1
//      exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice)
//
//      withClue(s"Counter sender should not have reserves:") {
//        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
//        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
//      }
//
//      withClue(s"Submitted sender should have reserved asset:") {
//        val (expectedAmountReserve, expectedPriceReserve) = if (counterType == BUY) (minAmountFor(submittedPrice), 0) else (0, 1)
//        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe expectedAmountReserve
//        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe expectedPriceReserve
//      }
//    }
//  }
//
//  forAll(
//    Table(
//      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
//      (BUY, 2.00434783.waves, 2.3.usd, 2.00434782.waves, 2.3.usd),
//      (SELL, 2.00434783.waves, 2.3.usd, 2.00434782.waves, 2.3.usd)
//    )
//  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
//    property(
//      s"Counter and submitted reserves should be minAmount and 0 WHEN their remains and minAmount are (minAmount - 1): $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
//    ) {
//      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
//      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
//      initAddressesOf(counter, submitted)
//      val exec = execute(counter, submitted)
//
//      exec.executedAmount shouldBe 2.waves
//
//      exec.counterRemainingAmount shouldBe minAmountFor(counterPrice)
//      exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice) - 1
//
//      withClue(s"Counter sender should have reserved asset:") {
//        val (expectedAmountReserve, expectedPriceReserve) = if (counterType == BUY) (0, 1) else (minAmountFor(submittedPrice), 0)
//        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe expectedAmountReserve
//        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe expectedPriceReserve
//      }
//
//      withClue(s"Submitted sender should not have reserves:") {
//        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
//        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
//      }
//    }
//  }
//
//  override val matcherFee = 1L
//
//  private def limitOrderInfo(orderType: OrderType, amount: Long, price: Long): String = {
//    val denormalizedAmount = wavesUsdPair.amountAsset.dAmt(amount)
//    val denormalizedPrice = wavesUsdPair.priceAsset.dAmt(price)
//    s"LIMIT $orderType $denormalizedAmount ${wavesUsdPair.amountAsset.toStringWUE} @ $denormalizedPrice ${wavesUsdPair.priceAsset.toStringWUE}"
//  }
//
//  private def marketOrderInfo(orderType: OrderType, amount: Long, price: Long, feeAsset: Asset, spendableBalance: Map[Asset, Long]): String = {
//
//    val spendableBalanceStr = spendableBalance.map { case (asset, balance) => asset.toStringWUE -> asset.dAmt(balance) }.toString
//    val denormalizedAmount = wavesUsdPair.amountAsset.dAmt(amount)
//    val denormalizedPrice = wavesUsdPair.priceAsset.dAmt(price)
//
//    s"MARKET $orderType $denormalizedAmount ${wavesUsdPair.amountAsset.toStringWUE} @ $denormalizedPrice ${wavesUsdPair.priceAsset.toStringWUE}, " +
//    s"fee in ${feeAsset.toStringSRT(orderType)} asset ($matcherFee ${feeAsset.toStringWUE}), spendable balance = $spendableBalanceStr"
//  }
//
//  implicit private class AssetOps(asset: Asset) {
//
//    def toStringSRT(orderType: OrderType): String = orderType match {
//      case OrderType.BUY => if (asset == wavesUsdPair.priceAsset) "spent" else if (asset == wavesUsdPair.amountAsset) "received" else "third"
//      case OrderType.SELL => if (asset == wavesUsdPair.amountAsset) "spent" else if (asset == wavesUsdPair.priceAsset) "received" else "third"
//    }
//
//    def toStringWUE: String = asset match {
//      case Waves => "WAVES"
//      case `usd` => "USD"
//      case `eth` => "ETH"
//      case _ => "wtf"
//    }
//
//    def amt(value: Long): Long = asset match {
//      case Waves => value.toDouble.waves
//      case `usd` => value.toDouble.usd
//      case `eth` => value.toDouble.eth
//      case _ => value
//    }
//
//    def dAmt(value: Long): BigDecimal = asset match {
//      case Waves => BigDecimal(value) / Order.PriceConstant
//      case `usd` => BigDecimal(value) / 100
//      case `eth` => BigDecimal(value) / Order.PriceConstant
//      case _ => value
//    }
//
//  }
//
//  private def addressDirWithSpendableBalance(spendableBalances: Map[Asset, Long], testProbe: TestProbe): ActorRef = {
//
//    val blockchainInteraction = new BlockchainInteraction {
//      override def getFullBalances(address: Address, exclude: Set[Asset]): Future[AddressBalanceUpdates] = Future.successful(
//        AddressBalanceUpdates(
//          regular = spendableBalances.filterNot(p => exclude.contains(p._1)),
//          outgoingLeasing = None,
//          pessimisticCorrection = Map.empty
//        )
//      )
//    }
//
//    def createAddressActor(address: Address, recovered: Boolean): Props =
//      AddressActor.props(
//        owner = address,
//        time = time,
//        orderDb = TestOrderDb(100),
//        (_, _) => Future.successful(Right(())),
//        store = command => {
//          testProbe.ref ! command
//          Future.successful(Some(ValidatedCommandWithMeta(0L, System.currentTimeMillis, command)))
//        },
//        recovered,
//        blockchainInteraction,
//        getAssetDescription = assetBriefInfo
//      )
//
//    val addressDir = system.actorOf(
//      Props(
//        new AddressDirectoryActor(
//          TestOrderDb(100),
//          createAddressActor,
//          recovered = true
//        )
//      )
//    )
//
//    addressDir
//  }
//
//  private def placeMarketOrder(tp: TestProbe, addressDir: ActorRef, marketOrder: MarketOrder): Unit =
//    tp.send(
//      addressDir,
//      ForwardMessage(
//        marketOrder.order.senderPublicKey,
//        PlaceOrder(OrderValidator.ValidatedOrder(marketOrder.order, None, None), isMarket = true)
//      )
//    )
//
//  private def systemCancelMarketOrder(addressDir: ActorRef, marketOrder: MarketOrder): Unit =
//    addressDir ! AddressActor.Command.ApplyOrderBookCanceled(OrderCanceled(
//      marketOrder,
//      Events.OrderCanceledReason.BecameUnmatchable,
//      System.currentTimeMillis
//    ))
//
//  private def executeMarketOrder(addressDirWithOrderBookCache: ActorRef, marketOrder: MarketOrder, limitOrder: LimitOrder): OrderExecuted = {
//    val executionEvent = mkOrderExecuted(marketOrder, limitOrder, marketOrder.order.timestamp)
//
//    addressDirWithOrderBookCache ! AddressActor.Command.ApplyOrderBookAdded(OrderAdded(
//      limitOrder,
//      OrderAddedReason.RequestExecuted,
//      time.getTimestamp()
//    ))
//    addressDirWithOrderBookCache ! AddressActor.Command.ApplyOrderBookExecuted(AddressActor.OrderBookExecutedEvent(
//      executionEvent,
//      mkExchangeTx(executionEvent)
//    ))
//
//    executionEvent
//  }
//
//  private def amtMap(wavesAmt: Long = 0L, usdAmt: Long = 0L, ethAmt: Long = 0L): Map[Asset, Long] =
//    Map(Waves -> wavesAmt, usd -> usdAmt, eth -> ethAmt)
//
//  // noinspection ScalaStyle
//  forAll(
//    Table(
//      /** NOTE! Fee = 1 fee asset */
//      // format: off
//      ("market order type", "amount", "price", "fee asset", "spendable balance", "reserves map after placement"),
//      /** BUY, availableForSpending > required by spendable asset */
//      (BUY, 123.waves, 3.usd, usd,   amtMap(500.waves, 500.usd, 50.eth), amtMap(usdAmt = 370.usd)),                 // fee in spent asset (123 * 3 + 1)
//      (BUY, 123.waves, 3.usd, Waves, amtMap(500.waves, 500.usd, 50.eth), amtMap(1.waves, 369.usd)),                 // fee in received asset
//      (BUY, 0.1.waves, 3.usd, Waves, amtMap(500.waves, 500.usd, 50.eth), amtMap(1.waves, 0.3.usd)),                 // fee in received asset, received amount < fee
//      (BUY, 123.waves, 3.usd, eth,   amtMap(500.waves, 500.usd, 50.eth), amtMap(usdAmt = 369.usd, ethAmt = 1.eth)), // fee in third asset
//      /** SELL, availableForSpending > required by spendable asset  */
//      (SELL, 123.waves, 3.usd, Waves, amtMap(500.waves, 500.usd, 50.eth), amtMap(124.waves)),                 // fee in spent asset (123 + 1)
//      (SELL, 123.waves, 3.usd, usd,   amtMap(500.waves, 500.usd, 50.eth), amtMap(123.waves, 1.usd)),          // fee in received asset
//      (SELL, 0.1.waves, 3.usd, usd,   amtMap(500.waves, 500.usd, 50.eth), amtMap(0.1.waves, 1.usd)),          // fee in received asset, received amount < fee
//      (SELL, 123.waves, 3.usd, eth,   amtMap(500.waves, 500.usd, 50.eth), amtMap(123.waves, ethAmt = 1.eth)), // fee in third asset
//      /**
//        * BUY, availableForSpending < required by spendable asset
//        * Note:
//        *  - (BUY, 0.1.waves, 3.usd, usd,   amtMap(500.waves, 0.9.usd, 50.eth))  - required 1.usd (marketOrderVolume = 0, only fee required),   balance = 0.9.usd,   received amount = 0.0.usd,   BalanceNotEnough by USD
//        *  - (BUY, 0.1.waves, 3.usd, Waves, amtMap(0.8.waves, 500.usd, 50.eth))  - required 1.waves (marketOrderVolume = 0, only fee required), balance = 0.8.waves, received amount = 0.1.waves, BalanceNotEnough by WAVES
//        *  - (BUY, 123.waves, 3.usd, eth,   amtMap(500.waves, 500.usd, 0.9.eth)) - required 1.eth,                                              balance = 0.9.eth,   received amount = 0.0.eth,   BalanceNotEnough by ETH
//        */
//      (BUY, 123.waves, 3.usd, usd,   amtMap(500.waves, 300.usd,  50.eth), amtMap(usdAmt = 300.usd)),  // fee in spent asset
//      (BUY, 123.waves, 3.usd, Waves, amtMap(500.waves, 300.usd,  50.eth), amtMap(1.waves, 300.usd)),  // fee in received asset
//      (BUY, 0.1.waves, 3.usd, Waves, amtMap(500.waves, 0.15.usd, 50.eth), amtMap(1.waves, 0.15.usd)), // fee in received asset, received amount < fee
//      /**
//        * SELL, availableForSpending < required by spendable asset
//        * Note:
//        *  - (SELL, 0.1.waves, 3.usd, Waves, amtMap(0.9.waves, 500.usd, 50.eth))  - required 1.waves (marketOrderVolume = 0, only fee required), balance = 0.9.waves, received amount = 0.0.waves, BalanceNotEnough by WAVES
//        *  - (SELL, 0.1.waves, 3.usd, usd,   amtMap(500.waves, 0.6.usd, 50.eth))  - required 1.usd (marketOrderVolume = 0, only fee required),   balance = 0.6.usd,   received amount = 0.3.usd,   BalanceNotEnough by USD
//        *  - (SELL, 123.waves, 3.usd, eth,   amtMap(500.waves, 500.usd, 0.9.eth)) - required 1.eth,                                              balance = 0.9.eth,   received amount = 0.0.eth,   BalanceNotEnough by ETH
//        */
//      (SELL, 123.waves, 3.usd, Waves, amtMap(100.waves,  500.usd, 50.eth), amtMap(100.waves)),        // fee in spent asset
//      (SELL, 123.waves, 3.usd, usd,   amtMap(100.waves,  500.usd, 50.eth), amtMap(100.waves, 1.usd)), // fee in received asset
//      (SELL, 0.1.waves, 3.usd, usd,   amtMap(0.05.waves, 500.usd, 50.eth), amtMap(0.05.waves, 1.usd)) // fee in received asset, received amount < fee
//      // format: on
//    )
//  ) { (orderType: OrderType, amount: Long, price: Long, feeAsset: Asset, balance: Map[Asset, Long], reserves: Map[Asset, Long]) =>
//    property {
//      s"Reserves of the market order with no counters should be correct: ${marketOrderInfo(orderType, amount, price, feeAsset, balance)}"
//    } {
//
//      val tp = TestProbe()
//      val addressDir = addressDirWithSpendableBalance(balance, testProbe = tp)
//      val fee = Some(feeAsset.amt(matcherFee))
//
//      val order = orderType match {
//        case BUY => rawBuy(wavesUsdPair, amount, price, version = 3, feeAsset = feeAsset, matcherFee = fee)
//        case SELL => rawSell(wavesUsdPair, amount, price, version = 3, feeAsset = feeAsset, matcherFee = fee)
//      }
//      initAddressesOf(order)
//
//      def reservedBalanceBy(asset: Asset): Long = openVolume(order.senderPublicKey, asset, addressDir)
//
//      val marketOrder = MarketOrder(order, balance, None, None)
//      val expectedSpentAssetReserve = reserves(marketOrder.spentAsset)
//      val expectedReceiveAssetReserve = reserves(marketOrder.rcvAsset)
//      val expectedFeeAssetReserve = reserves(marketOrder.feeAsset)
//
//      placeMarketOrder(tp, addressDir, marketOrder)
//      val validated = tp.expectMsgType[ValidatedCommand.PlaceMarketOrder]
//      validated should matchTo(ValidatedCommand.PlaceMarketOrder(marketOrder))
//
//      addressDir ! AddressActor.Command.ApplyOrderBookAdded(OrderAdded(
//        validated.marketOrder,
//        reason = OrderAddedReason.RequestExecuted,
//        timestamp = marketOrder.order.timestamp
//      ))
//
//      withClue {
//        s"Place market $orderType order, fee in ${feeAsset.toStringSRT(orderType)} asset, " +
//        s"expected reserves (spent/received/fee) = $expectedSpentAssetReserve/$expectedReceiveAssetReserve/$expectedFeeAssetReserve:\n"
//      } {
//        reservedBalanceBy(marketOrder.spentAsset) shouldBe expectedSpentAssetReserve
//        reservedBalanceBy(marketOrder.rcvAsset) shouldBe expectedReceiveAssetReserve
//        reservedBalanceBy(marketOrder.feeAsset) shouldBe expectedFeeAssetReserve
//      }
//
//      systemCancelMarketOrder(addressDir, marketOrder)
//
//      withClue(s"System cancel of $orderType market order:\n") {
//        reservedBalanceBy(marketOrder.spentAsset) shouldBe 0
//        reservedBalanceBy(marketOrder.rcvAsset) shouldBe 0
//        reservedBalanceBy(marketOrder.feeAsset) shouldBe 0
//      }
//    }
//  }
//
//  // noinspection ScalaStyle
//  forAll(
//    Table(
//      /** NOTE! Fee = 1 fee asset */
//      // format: off
//      ("mo type", "mo amount", "mo price", "mo fee asset", "spendable balance", "lo amount", "lo price", "reserves map after execution"),
//      /** r              = required,
//        * f              = fee,
//        * ea             = executed amount,
//        * eap            = executed amount of price asset,
//        * ef             = executed fee,
//        * afs            = available for spending,
//        * ea*, ef*, eap* = calculated by the formula AcceptedOrder.executedAmount */
//      /** market BUY order PARTIALLY filled, available for spending > required by spendable asset */
//      (BUY, 123.waves, 3.usd, usd,   amtMap(500.waves, 500.usd, 50.eth), 100.waves, 2.usd, amtMap(usdAmt = 169.19.usd)),                       // fee in spent asset,    USD: 123 * 3 [r] + 1 [f] - 100 * 2 [eap] - 100/123 [ef]
//      (BUY, 123.waves, 3.usd, Waves, amtMap(500.waves, 500.usd, 50.eth), 100.waves, 2.usd, amtMap(0.18699187.waves, 169.usd)),                 // fee in received asset, USD: 123 * 3 [r] - 100 * 2 [eap], Waves: 1 [f] - 100/123 [ef]
//      (BUY, 123.waves, 3.usd, eth,   amtMap(500.waves, 500.usd, 50.eth), 100.waves, 2.usd, amtMap(usdAmt = 169.usd, ethAmt = 0.18699187.eth)), // fee in third asset,    USD: 123 * 3 [r] - 100 * 2 [eap], ETH: 1 [f] - 100/123 [ef]
//      /** market BUY order filled, available for spending > required by spendable asset */
//      (BUY, 100.waves, 3.usd, usd,   amtMap(500.waves, 500.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in spent asset
//      (BUY, 100.waves, 3.usd, Waves, amtMap(500.waves, 500.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in received asset
//      (BUY, 100.waves, 3.usd, eth,   amtMap(500.waves, 500.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in third asset
//      /** market SELL order PARTIALLY filled, available for spending > required by spendable asset */
//      (SELL, 123.waves, 2.usd, Waves, amtMap(500.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(23.18699187.waves)),                 // fee in spent asset,    Waves: 123 [r] + 1 [f] - 100 [ea] - 100/123 [ef]
//      (SELL, 123.waves, 2.usd, usd,   amtMap(500.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(23.waves, 0.19.usd)),                // fee in received asset, Waves: 123 [r] - 100 [ea], USD: 1 [f] - 100/123 [ef]
//      (SELL, 123.waves, 2.usd, eth,   amtMap(500.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(23.waves, ethAmt = 0.18699187.eth)), // fee in third asset,    Waves: 123 [r] - 100 [ea], ETH: 1 [f] - 100/123 [ef]
//      /** market SELL order filled, available for spending > required by spendable asset */
//      (SELL, 100.waves, 2.usd, Waves, amtMap(500.waves, 500.usd, 50.eth), 200.waves, 3.usd, amtMap()), // fee in spent asset
//      (SELL, 100.waves, 2.usd, usd,   amtMap(500.waves, 500.usd, 50.eth), 200.waves, 3.usd, amtMap()), // fee in received asset
//      (SELL, 100.waves, 2.usd, eth,   amtMap(500.waves, 500.usd, 50.eth), 200.waves, 3.usd, amtMap()), // fee in third asset
//      /** market BUY order PARTIALLY filled, available for spending < required by spendable asset, but is enough to cover market cost and fee */
//      (BUY, 123.waves, 3.usd, usd,   amtMap(500.waves, 300.usd, 50.eth), 100.waves, 2.usd, amtMap(usdAmt = 99.19.usd)),                        // fee in spent asset,    USD: 300 [afs] - 100 * 2 [eap] - 100/123 [ef]
//      (BUY, 123.waves, 3.usd, Waves, amtMap(500.waves, 300.usd, 50.eth), 100.waves, 2.usd, amtMap(0.18699187.waves, 100.usd)),                 // fee in received asset, USD: 300 [afs] - 100 * 2 [eap], Waves: 1 [f] - 100/123 [ef]
//      (BUY, 123.waves, 3.usd, eth,   amtMap(500.waves, 300.usd, 50.eth), 100.waves, 2.usd, amtMap(usdAmt = 100.usd, ethAmt = 0.18699187.eth)), // fee in third asset,    USD: 300 [afs] - 100 * 2 [eap], ETH: 1 [f] - 100/123 [ef]
//      /** market BUY order PARTIALLY filled, available for spending < required by spendable asset and is NOT enough to cover market cost and fee */
//      (BUY, 100.waves, 3.usd, usd,   amtMap(500.waves, 300.usd, 50.eth), 100.waves, 3.usd, amtMap(usdAmt = 0.01.usd)),                          // fee in spent asset,    USD: 300 [afs] - 299.00 [eap*] - 0.99 [ef*]
//      (BUY, 100.waves, 3.usd, usd,   amtMap(500.waves, 290.usd, 50.eth), 100.waves, 3.usd, amtMap(usdAmt = 0.01.usd)),                          // fee in spent asset,    USD: 290 [afs] - 289.03 [eap*] - 0.96 [ef*]
//      (BUY, 100.waves, 3.usd, Waves, amtMap(500.waves, 290.usd, 50.eth), 100.waves, 3.usd, amtMap(0.03336667.waves, 0.01.usd)),                 // fee in received asset, USD: 290 [afs] - 289.99 [eap*], Waves: 1 [f] - 96.66333334 [ea*]
//      (BUY, 100.waves, 3.usd, eth,   amtMap(500.waves, 290.usd, 50.eth), 100.waves, 3.usd, amtMap(usdAmt = 0.01.usd, ethAmt = 0.03336667.eth)), // fee in third asset,    USD: 290 [afs] - 289.99 [eap*], ETH = 1 [f] - 0.96663333 [ef*]
//      /** market BUY order filled, available for spending = required by spendable asset */
//      (BUY, 100.waves, 3.usd, usd,   amtMap(500.waves, 301.usd, 50.eth), 100.waves, 3.usd, amtMap()), // fee in spent asset
//      (BUY, 100.waves, 3.usd, Waves, amtMap(500.waves, 300.usd, 50.eth), 100.waves, 3.usd, amtMap()), // fee in received asset
//      (BUY, 100.waves, 3.usd, eth,   amtMap(500.waves, 300.usd, 50.eth), 100.waves, 3.usd, amtMap()), // fee in third asset
//      /** market BUY order filled, available for spending < required by spendable asset */
//      (BUY, 100.waves, 3.usd, usd,   amtMap(500.waves, 250.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in spent asset
//      (BUY, 100.waves, 3.usd, Waves, amtMap(500.waves, 250.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in received asset
//      (BUY, 100.waves, 3.usd, eth,   amtMap(500.waves, 250.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in third asset
//      /** market SELL order PARTIALLY filled, available for spending < required by spendable asset but is enough to cover market amount and fee */
//      (SELL, 123.waves, 2.usd, Waves, amtMap(110.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(9.18699187.waves)),                  // fee in spent asset,    Waves: 110 [afs] - 100 [ea] - 100/123 [ef]
//      (SELL, 123.waves, 2.usd, usd,   amtMap(110.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(10.waves, 0.19.usd)),                // fee in received asset, Waves: 110 [afs] - 100 [ea], USD: 1 [f] - 100/123 [ef]
//      (SELL, 123.waves, 2.usd, eth,   amtMap(110.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(10.waves, ethAmt = 0.18699187.eth)), // fee in third asset,    Waves: 110 [afs] - 100 [ea], USD: 1 [f] - 100/123 [ef]
//      /** market SELL order PARTIALLY filled, available for spending < required by spendable asset and NOT enough to cover market amount and fee */
//      (SELL, 123.waves, 2.usd, Waves, amtMap(100.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(0.00000001.waves)),        // fee in spent asset,    Waves: 100 [afs] - 99.19354838 [ea*] - 0.80645161 [ef*]
//      (SELL, 123.waves, 2.usd, Waves, amtMap(90.waves, 500.usd, 50.eth),  100.waves, 3.usd, amtMap(0.00000001.waves)),        // fee in spent asset,    Waves:  90 [afs] - 89.27419354 [ea*] - 0.72580645 [ef*]
//      (SELL, 123.waves, 2.usd, usd,   amtMap(90.waves, 500.usd, 50.eth),  100.waves, 3.usd, amtMap(usdAmt = 0.27.usd)),       // fee in received asset, USD: 1 [f] - 90/123 [ef]
//      (SELL, 123.waves, 2.usd, eth,   amtMap(90.waves, 500.usd, 50.eth),  100.waves, 3.usd, amtMap(ethAmt = 0.26829269.eth)), // fee in third asset,    ETH: 1 [f] - 90/123 [ef]
//      /** market SELL order filled, available for spending = required by spendable asset */
//      (SELL, 100.waves, 3.usd, Waves, amtMap(101.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap()), // fee in spent asset
//      (SELL, 100.waves, 3.usd, usd,   amtMap(100.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap()), // fee in received asset
//      (SELL, 100.waves, 3.usd, eth,   amtMap(100.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap()) // fee in third asset
//      /** market SELL order filled, available for spending < required by spendable asset - impossible case */
//      // format: on
//    )
//  ) {
//    (
//      moTpe: OrderType,
//      moAmt: Long,
//      moPrc: Long,
//      moFeeAsst: Asset,
//      balance: Map[Asset, Long],
//      loAmt: Long,
//      loPrc: Long,
//      reserves: Map[Asset, Long]
//    ) =>
//      property {
//        s"Reserves of the market order (${marketOrderInfo(moTpe, moAmt, moPrc, moFeeAsst, balance)}) executed with the counter order (${limitOrderInfo(moTpe.opposite, loAmt, loPrc)}) should be correct"
//      } {
//
//        val tp = TestProbe()
//        val addressDir = addressDirWithSpendableBalance(balance, tp)
//        val fee = Some(moFeeAsst.amt(matcherFee))
//
//        val (order, counter) = moTpe match {
//          case BUY =>
//            rawBuy(wavesUsdPair, moAmt, moPrc, version = 3, feeAsset = moFeeAsst, matcherFee = fee) -> rawSell(wavesUsdPair, loAmt, loPrc)
//          case SELL =>
//            rawSell(wavesUsdPair, moAmt, moPrc, version = 3, feeAsset = moFeeAsst, matcherFee = fee) -> rawBuy(wavesUsdPair, loAmt, loPrc)
//        }
//        initAddressesOf(counter, order)
//
//        def reservedBalanceBy(asset: Asset): Long = openVolume(order.senderPublicKey, asset, addressDir)
//
//        val marketOrder = MarketOrder(order, balance, None, None)
//
//        placeMarketOrder(tp, addressDir, marketOrder)
//        tp.expectMsgType[ValidatedCommand.PlaceMarketOrder]
//
//        val orderExecutedEvent = executeMarketOrder(addressDir, marketOrder, LimitOrder(counter, None, None))
//
//        val expectedSpentAssetReserve = reserves(marketOrder.spentAsset)
//        val expectedReceiveAssetReserve = reserves(marketOrder.rcvAsset)
//        val expectedFeeAssetReserve = reserves(marketOrder.feeAsset)
//
//        withClue {
//          s"Execution:\n" +
//          s"MARKET $moTpe ($moAmt ${wavesUsdPair.amountAsset.toStringWUE} @ $moPrc ${wavesUsdPair.priceAsset.toStringWUE}, " +
//          s"fee = ${moFeeAsst.amt(matcherFee)} ${moFeeAsst.toStringWUE}, " +
//          s"afs = ${marketOrder.availableForSpending} ${marketOrder.spentAsset.toStringWUE}),\n" +
//          s"LIMIT ${moTpe.opposite} ($loAmt ${wavesUsdPair.amountAsset.toStringWUE} @ $loPrc ${wavesUsdPair.priceAsset.toStringWUE}),\n" +
//          s"expected reserves after execution (spent/received/fee) = " +
//          s"$expectedSpentAssetReserve/$expectedReceiveAssetReserve/$expectedFeeAssetReserve:\n"
//        } {
//          reservedBalanceBy(marketOrder.spentAsset) shouldBe expectedSpentAssetReserve
//          reservedBalanceBy(marketOrder.rcvAsset) shouldBe expectedReceiveAssetReserve
//          reservedBalanceBy(marketOrder.feeAsset) shouldBe expectedFeeAssetReserve
//        }
//
//        systemCancelMarketOrder(addressDir, orderExecutedEvent.submittedMarketRemaining(marketOrder))
//
//        withClue(s"System cancel of $moTpe market order remaining:\n") {
//          reservedBalanceBy(marketOrder.spentAsset) shouldBe 0
//          reservedBalanceBy(marketOrder.rcvAsset) shouldBe 0
//          reservedBalanceBy(marketOrder.feeAsset) shouldBe 0
//        }
//      }
//  }
//
//  private def initAddressesOf(orders: Order*): Unit =
//    orders.map(_.sender.toAddress).foreach { address =>
//      addressDir ! AddressDirectoryActor.Command.ForwardMessage(
//        address,
//        AddressActor.Command.SetInitialBalances(Success(AddressBalanceUpdates.empty), 0)
//      )
//    }
//
//}
