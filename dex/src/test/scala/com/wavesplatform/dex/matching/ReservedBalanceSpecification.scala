package com.wavesplatform.dex.matching

import akka.actor.{ActorRef, Props}
import akka.pattern.ask
import akka.testkit.TestProbe
import com.wavesplatform.dex.MatcherSpecBase
import com.wavesplatform.dex.actors.MatcherSpecLike
import com.wavesplatform.dex.actors.address.AddressActor.BlockchainInteraction
import com.wavesplatform.dex.actors.address.AddressActor.Command.PlaceOrder
import com.wavesplatform.dex.actors.address.AddressDirectoryActor.Command.ForwardMessage
import com.wavesplatform.dex.actors.address.{AddressActor, AddressDirectoryActor}
import com.wavesplatform.dex.db.{EmptyOrderDb, TestOrderDb, WithDb}
import com.wavesplatform.dex.domain.account.{Address, PublicKey}
import com.wavesplatform.dex.domain.asset.Asset.Waves
import com.wavesplatform.dex.domain.asset.{Asset, AssetPair}
import com.wavesplatform.dex.domain.order.OrderType.{BUY, SELL}
import com.wavesplatform.dex.domain.order.{Order, OrderType}
import com.wavesplatform.dex.error.ErrorFormatterContext
import com.wavesplatform.dex.grpc.integration.clients.domain.AddressBalanceUpdates
import com.wavesplatform.dex.grpc.integration.dto.BriefAssetDescription
import com.wavesplatform.dex.model.Events.{OrderAdded, OrderAddedReason, OrderCanceled, OrderExecuted}
import com.wavesplatform.dex.model.{Events, LimitOrder, MarketOrder}
import com.wavesplatform.dex.queue.{ValidatedCommand, ValidatedCommandWithMeta}
import org.scalatest.prop.TableDrivenPropertyChecks
import org.scalatest.propspec.AnyPropSpecLike

import scala.concurrent.duration.Duration
import scala.concurrent.{Await, Future}
import scala.math.BigDecimal.RoundingMode.CEILING
import scala.util.Success

/**
 * Tests for reserved balance
 *
 * This specification checks how different cases affect reserved balance.
 *
 * Test cases was generated by filtered decision table:
 *
 * Field Name          | Values                          | Description
 * -------------------------------------------------------------------
 * CounterType         | Buy, Sell                       | Submitted type will be set automatically
 * Amounts             | A_c = A_s, A_c > A_s, A_c < A_s | A_c - counter amount, A_s - submitted amount
 * CorrectedAmount     | A_corr = A, A_corr < A          | A - match amount
 * Prices              | P_c = P_s, P_c != P_s           | P_c - counter price, P_s - submitted price
 * CounterRestAmount   | 0, A_min, A_min - 1             | Rest amount after matching. A_min - minimal amount can be filled by the price
 * SubmittedRestAmount | 0, A_min, A_min - 1             | Rest amount after matching. A_min - minimal amount can be filled by the price
 *
 * CounterType | Amounts   | CorrectedAmount | Prices     | CounterRestAmount | SubmittedRestAmount
 * ------------------------------------------------------------------------------------------------
 * Buy         | A_c = A_s | A_corr = A      | P_c = P_s  | 0                 | 0
 * Sell        | A_c = A_s | A_corr = A      | P_c = P_s  | 0                 | 0
 * Buy         | A_c = A_s | A_corr = A      | P_c != P_s | 0                 | 0
 * Sell        | A_c = A_s | A_corr = A      | P_c != P_s | 0                 | 0
 * Buy         | A_c > A_s | A_corr = A      | P_c = P_s  | A_min - 1         | 0
 * Sell        | A_c > A_s | A_corr = A      | P_c = P_s  | A_min - 1         | 0
 * Buy         | A_c > A_s | A_corr = A      | P_c != P_s | A_min - 1         | 0
 * Sell        | A_c > A_s | A_corr = A      | P_c != P_s | A_min - 1         | 0
 * Buy         | A_c < A_s | A_corr = A      | P_c = P_s  | 0                 | A_min - 1
 * Sell        | A_c < A_s | A_corr = A      | P_c = P_s  | 0                 | A_min - 1
 * Buy         | A_c < A_s | A_corr = A      | P_c != P_s | 0                 | A_min - 1
 * Sell        | A_c < A_s | A_corr = A      | P_c != P_s | 0                 | A_min - 1
 * Buy         | A_c > A_s | A_corr = A      | P_c = P_s  | A_min             | 0
 * Sell        | A_c > A_s | A_corr = A      | P_c = P_s  | A_min             | 0
 * Buy         | A_c > A_s | A_corr = A      | P_c != P_s | A_min             | 0
 * Sell        | A_c > A_s | A_corr = A      | P_c != P_s | A_min             | 0
 * Buy         | A_c < A_s | A_corr = A      | P_c = P_s  | 0                 | A_min
 * Sell        | A_c < A_s | A_corr = A      | P_c = P_s  | 0                 | A_min
 * Buy         | A_c < A_s | A_corr = A      | P_c != P_s | 0                 | A_min
 * Sell        | A_c < A_s | A_corr = A      | P_c != P_s | 0                 | A_min
 * Buy         | A_c = A_s | A_corr < A      | P_c = P_s  | A_min - 1         | A_min - 1
 * Sell        | A_c = A_s | A_corr < A      | P_c = P_s  | A_min - 1         | A_min - 1
 * Buy         | A_c < A_s | A_corr < A      | P_c = P_s  | A_min - 1         | A_min
 * Sell        | A_c < A_s | A_corr < A      | P_c = P_s  | A_min - 1         | A_min
 * Buy         | A_c > A_s | A_corr < A      | P_c = P_s  | A_min             | A_min - 1
 * Sell        | A_c > A_s | A_corr < A      | P_c = P_s  | A_min             | A_min - 1
 */
class ReservedBalanceSpecification extends AnyPropSpecLike with MatcherSpecLike with WithDb with MatcherSpecBase with TableDrivenPropertyChecks {

  import system.dispatcher

  implicit private val efc: ErrorFormatterContext = ErrorFormatterContext.from(_ => 8)

  private val pair: AssetPair = AssetPair(mkAssetId("WAVES"), mkAssetId("USD"))

  private val addressDir = system.actorOf(
    Props(
      new AddressDirectoryActor(
        EmptyOrderDb(),
        createAddressActor,
        None,
        recovered = true
      )
    )
  )

  private val emptyAddressBalanceUpdatesF = Future.successful(AddressBalanceUpdates.empty)

  private val blockchainInteraction = new BlockchainInteraction {
    override def getFullBalances(address: Address, exclude: Set[Asset]): Future[AddressBalanceUpdates] = emptyAddressBalanceUpdatesF
  }

  private def assetBriefInfo: Asset => BriefAssetDescription =
    asset => BriefAssetDescription(asset.toString, 2, hasScript = false)

  private def createAddressActor(address: Address, recovered: Boolean): Props =
    Props(
      new AddressActor(
        address,
        time,
        TestOrderDb(100),
        (_, _) => Future.successful(Right(())),
        _ => Future.failed(new IllegalStateException("Should not be used in the test")),
        recovered,
        blockchainInteraction,
        getAssetDescription = assetBriefInfo
      )
    )

  private def minAmountFor(price: Long, amountDecimals: Int = 8): Long = { BigDecimal(Math.pow(10, amountDecimals)) / BigDecimal(price) }
    .setScale(0, CEILING)
    .toLong

  private def openVolume(senderPublicKey: PublicKey, assetId: Asset, addressDirectory: ActorRef = addressDir): Long =
    Await
      .result(
        (addressDirectory ? AddressDirectoryActor.Command.ForwardMessage(senderPublicKey, AddressActor.Query.GetReservedBalance))
          .mapTo[AddressActor.Reply.GetBalance].map(_.balance),
        Duration.Inf
      )
      .getOrElse(assetId, 0L)

  def execute(counter: Order, submitted: Order): OrderExecuted = {
    val now = time.getTimestamp()

    addressDir ! AddressActor.Command.ApplyOrderBookAdded(OrderAdded(LimitOrder(counter), OrderAddedReason.RequestExecuted, now))
    addressDir ! AddressActor.Command.ApplyOrderBookAdded(OrderAdded(LimitOrder(submitted), OrderAddedReason.RequestExecuted, now))
    val exec = OrderExecuted(LimitOrder(submitted), LimitOrder(counter), submitted.timestamp, counter.matcherFee, submitted.matcherFee)
    addressDir ! AddressActor.Command.ApplyOrderBookExecuted(exec, None)
    exec
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.waves, 2.3.usd, 2.waves, 2.3.usd),
      (SELL, 2.waves, 2.3.usd, 2.waves, 2.3.usd),
      (BUY, 2.waves, 2.3.usd, 2.waves, 2.2.usd),
      (SELL, 2.waves, 2.2.usd, 2.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(s"Reserves should be 0 when remains are 0: $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice") {
      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      initAddressesOf(counter, submitted)
      val exec = execute(counter, submitted)

      withClue("Both orders should be filled") {
        exec.executedAmount shouldBe counter.amount
      }

      withClue("All remains should be 0") {
        exec.counterRemainingAmount shouldBe 0
        exec.submittedRemainingAmount shouldBe 0
      }

      withClue(s"Counter sender should not have reserves") {
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
      }

      withClue(s"Submitted sender should not have reserves") {
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
      }
    }
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.00434782.waves, 2.3.usd, 2.waves, 2.3.usd),
      (SELL, 2.00434782.waves, 2.3.usd, 2.waves, 2.3.usd),
      (BUY, 2.00434782.waves, 2.3.usd, 2.waves, 2.2.usd),
      (SELL, 2.00454545.waves, 2.2.usd, 2.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(
      s"Counter reserves should be 0 WHEN remain is (minAmount - 1): $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
    ) {
      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      initAddressesOf(counter, submitted)
      val exec = execute(counter, submitted)

      withClue("Both orders should be filled") {
        exec.executedAmount shouldBe submittedAmount
      }

      withClue("Counter remain should be (minAmount - 1):") {
        exec.counterRemainingAmount shouldBe minAmountFor(counterPrice) - 1
        exec.submittedRemainingAmount shouldBe 0
      }

      withClue(s"Counter sender should not have reserves:") {
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
      }

      withClue(s"Submitted sender should not have reserves:") {
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
      }
    }
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.waves, 2.3.usd, 2.00434782.waves, 2.3.usd),
      (SELL, 2.waves, 2.3.usd, 2.00434782.waves, 2.3.usd),
      (BUY, 2.waves, 2.3.usd, 2.00454545.waves, 2.2.usd),
      (SELL, 2.waves, 2.2.usd, 2.00434782.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(
      s"Submitted reserves should be 0 WHEN remain is (minAmount - 1): $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
    ) {
      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      initAddressesOf(counter, submitted)
      val exec = execute(counter, submitted)

      withClue("Both orders should be filled") {
        exec.executedAmount shouldBe counterAmount
      }

      withClue("Submitted remain should be (minAmount - 1):") {
        exec.counterRemainingAmount shouldBe 0
        exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice) - 1
      }

      withClue(s"Counter sender should not have reserves:") {
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
      }

      withClue(s"Submitted sender should not have reserves:") {
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
      }
    }
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.00434783.waves, 2.3.usd, 2.waves, 2.3.usd),
      (SELL, 2.00434783.waves, 2.3.usd, 2.waves, 2.3.usd),
      (BUY, 2.00434783.waves, 2.3.usd, 2.waves, 2.2.usd),
      (SELL, 2.00454546.waves, 2.2.usd, 2.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(
      s"Counter reserve should be minAmount WHEN remain is minAmount: $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
    ) {
      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      initAddressesOf(counter, submitted)
      val exec = execute(counter, submitted)

      withClue("Counter should be partially filled:") {
        exec.executedAmount shouldBe submittedAmount
      }

      withClue("Counter remain should be minAmount:") {
        exec.counterRemainingAmount shouldBe minAmountFor(counterPrice)
        exec.submittedRemainingAmount shouldBe 0
      }

      withClue(s"Counter sender should have reserved asset:") {
        val (expectedAmountReserve, expectedPriceReserve) = if (counterType == BUY) (0, 1) else (minAmountFor(counterPrice), 0)
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe expectedAmountReserve
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe expectedPriceReserve
      }

      withClue(s"Submitted sender should not have reserves:") {
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
      }
    }
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.waves, 2.3.usd, 2.00434783.waves, 2.3.usd),
      (SELL, 2.waves, 2.3.usd, 2.00434783.waves, 2.3.usd),
      (BUY, 2.waves, 2.3.usd, 2.00454546.waves, 2.2.usd),
      (SELL, 2.waves, 2.2.usd, 2.00434783.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(
      s"Submitted reserve should be minAmount WHEN remain is minAmount: $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
    ) {
      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      initAddressesOf(counter, submitted)
      val exec = execute(counter, submitted)

      withClue("Submitted should be partially filled:") {
        exec.executedAmount shouldBe counterAmount
      }

      withClue("Submitted remain should be minAmount:") {
        exec.counterRemainingAmount shouldBe 0
        exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice)
      }

      withClue(s"Counter sender should not have reserves:") {
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
      }

      withClue(s"Submitted sender should have reserved asset:") {
        val (expectedAmountReserve, expectedPriceReserve) = if (counterType == BUY) (minAmountFor(submittedPrice), 0) else (0, 1)
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe expectedAmountReserve
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe expectedPriceReserve
      }
    }
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.00434782.waves, 2.3.usd, 2.00434782.waves, 2.3.usd),
      (SELL, 2.00434782.waves, 2.3.usd, 2.00434782.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(
      s"Counter and submitted reserves should be 0 WHEN both remains are (minAmount - 1): $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
    ) {
      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      initAddressesOf(counter, submitted)
      val exec = execute(counter, submitted)

      exec.executedAmount shouldBe 2.waves

      exec.counterRemainingAmount shouldBe minAmountFor(counterPrice) - 1
      exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice) - 1

      withClue(s"Counter sender should not have reserves:") {
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
      }

      withClue(s"Submitted sender should not have reserves:") {
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
      }
    }
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.00434782.waves, 2.3.usd, 2.00434783.waves, 2.3.usd),
      (SELL, 2.00434782.waves, 2.3.usd, 2.00434783.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(
      s"Counter and submitted reserves should be 0 and minAmount WHEN their remains are (minAmount - 1) and minAmount: $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
    ) {
      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      initAddressesOf(counter, submitted)
      val exec = execute(counter, submitted)

      exec.executedAmount shouldBe 2.waves

      exec.counterRemainingAmount shouldBe minAmountFor(counterPrice) - 1
      exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice)

      withClue(s"Counter sender should not have reserves:") {
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
      }

      withClue(s"Submitted sender should have reserved asset:") {
        val (expectedAmountReserve, expectedPriceReserve) = if (counterType == BUY) (minAmountFor(submittedPrice), 0) else (0, 1)
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe expectedAmountReserve
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe expectedPriceReserve
      }
    }
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.00434783.waves, 2.3.usd, 2.00434782.waves, 2.3.usd),
      (SELL, 2.00434783.waves, 2.3.usd, 2.00434782.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(
      s"Counter and submitted reserves should be minAmount and 0 WHEN their remains and minAmount are (minAmount - 1): $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
    ) {
      val counter = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      initAddressesOf(counter, submitted)
      val exec = execute(counter, submitted)

      exec.executedAmount shouldBe 2.waves

      exec.counterRemainingAmount shouldBe minAmountFor(counterPrice)
      exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice) - 1

      withClue(s"Counter sender should have reserved asset:") {
        val (expectedAmountReserve, expectedPriceReserve) = if (counterType == BUY) (0, 1) else (minAmountFor(submittedPrice), 0)
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe expectedAmountReserve
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe expectedPriceReserve
      }

      withClue(s"Submitted sender should not have reserves:") {
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
      }
    }
  }

  override val matcherFee = 1L

  private def limitOrderInfo(orderType: OrderType, amount: Long, price: Long): String = {
    val denormalizedAmount = wavesUsdPair.amountAsset.dAmt(amount)
    val denormalizedPrice = wavesUsdPair.priceAsset.dAmt(price)
    s"LIMIT $orderType $denormalizedAmount ${wavesUsdPair.amountAsset.toStringWUE} @ $denormalizedPrice ${wavesUsdPair.priceAsset.toStringWUE}"
  }

  private def marketOrderInfo(orderType: OrderType, amount: Long, price: Long, feeAsset: Asset, spendableBalance: Map[Asset, Long]): String = {

    val spendableBalanceStr = spendableBalance.map { case (asset, balance) => asset.toStringWUE -> asset.dAmt(balance) }.toString
    val denormalizedAmount = wavesUsdPair.amountAsset.dAmt(amount)
    val denormalizedPrice = wavesUsdPair.priceAsset.dAmt(price)

    s"MARKET $orderType $denormalizedAmount ${wavesUsdPair.amountAsset.toStringWUE} @ $denormalizedPrice ${wavesUsdPair.priceAsset.toStringWUE}, " +
    s"fee in ${feeAsset.toStringSRT(orderType)} asset ($matcherFee ${feeAsset.toStringWUE}), spendable balance = $spendableBalanceStr"
  }

  implicit private class AssetOps(asset: Asset) {

    def toStringSRT(orderType: OrderType): String = orderType match {
      case OrderType.BUY => if (asset == wavesUsdPair.priceAsset) "spent" else if (asset == wavesUsdPair.amountAsset) "received" else "third"
      case OrderType.SELL => if (asset == wavesUsdPair.amountAsset) "spent" else if (asset == wavesUsdPair.priceAsset) "received" else "third"
    }

    def toStringWUE: String = asset match {
      case Waves => "WAVES"
      case `usd` => "USD"
      case `eth` => "ETH"
      case _ => "wtf"
    }

    def amt(value: Long): Long = asset match {
      case Waves => value.toDouble.waves
      case `usd` => value.toDouble.usd
      case `eth` => value.toDouble.eth
      case _ => value
    }

    def dAmt(value: Long): BigDecimal = asset match {
      case Waves => BigDecimal(value) / Order.PriceConstant
      case `usd` => BigDecimal(value) / 100
      case `eth` => BigDecimal(value) / Order.PriceConstant
      case _ => value
    }

  }

  private def addressDirWithSpendableBalance(spendableBalances: Map[Asset, Long], testProbe: TestProbe): ActorRef = {

    val blockchainInteraction = new BlockchainInteraction {
      override def getFullBalances(address: Address, exclude: Set[Asset]): Future[AddressBalanceUpdates] = Future.successful(
        AddressBalanceUpdates(
          regular = spendableBalances.filterNot(p => exclude.contains(p._1)),
          outgoingLeasing = None,
          pessimisticCorrection = Map.empty
        )
      )
    }

    def createAddressActor(address: Address, recovered: Boolean): Props =
      Props(
        new AddressActor(
          owner = address,
          time = time,
          orderDb = TestOrderDb(100),
          (_, _) => Future.successful(Right(())),
          store = command => {
            testProbe.ref ! command
            Future.successful(Some(ValidatedCommandWithMeta(0L, System.currentTimeMillis, command)))
          },
          recovered,
          blockchainInteraction,
          getAssetDescription = assetBriefInfo
        )
      )

    val addressDir = system.actorOf(
      Props(
        new AddressDirectoryActor(
          TestOrderDb(100),
          createAddressActor,
          None,
          recovered = true
        )
      )
    )

    addressDir
  }

  private def placeMarketOrder(tp: TestProbe, addressDir: ActorRef, marketOrder: MarketOrder): Unit =
    tp.send(addressDir, ForwardMessage(marketOrder.order.senderPublicKey, PlaceOrder(marketOrder.order, isMarket = true)))

  private def systemCancelMarketOrder(addressDir: ActorRef, marketOrder: MarketOrder): Unit =
    addressDir ! AddressActor.Command.ApplyOrderBookCanceled(OrderCanceled(
      marketOrder,
      Events.OrderCanceledReason.BecameUnmatchable,
      System.currentTimeMillis
    ))

  private def executeMarketOrder(addressDirWithOrderBookCache: ActorRef, marketOrder: MarketOrder, limitOrder: LimitOrder): OrderExecuted = {
    val executionEvent = mkOrderExecuted(marketOrder, limitOrder, marketOrder.order.timestamp)

    addressDirWithOrderBookCache ! AddressActor.Command.ApplyOrderBookAdded(OrderAdded(
      limitOrder,
      OrderAddedReason.RequestExecuted,
      time.getTimestamp()
    ))
    addressDirWithOrderBookCache ! AddressActor.Command.ApplyOrderBookExecuted(executionEvent, None)

    executionEvent
  }

  private def amtMap(wavesAmt: Long = 0L, usdAmt: Long = 0L, ethAmt: Long = 0L): Map[Asset, Long] =
    Map(Waves -> wavesAmt, usd -> usdAmt, eth -> ethAmt)

  // noinspection ScalaStyle
  forAll(
    Table(
      /** NOTE! Fee = 1 fee asset */
      // format: off
      ("market order type", "amount", "price", "fee asset", "spendable balance", "reserves map after placement"),
      /** BUY, availableForSpending > required by spendable asset */
      (BUY, 123.waves, 3.usd, usd,   amtMap(500.waves, 500.usd, 50.eth), amtMap(usdAmt = 370.usd)),                 // fee in spent asset (123 * 3 + 1)
      (BUY, 123.waves, 3.usd, Waves, amtMap(500.waves, 500.usd, 50.eth), amtMap(1.waves, 369.usd)),                 // fee in received asset
      (BUY, 0.1.waves, 3.usd, Waves, amtMap(500.waves, 500.usd, 50.eth), amtMap(1.waves, 0.3.usd)),                 // fee in received asset, received amount < fee
      (BUY, 123.waves, 3.usd, eth,   amtMap(500.waves, 500.usd, 50.eth), amtMap(usdAmt = 369.usd, ethAmt = 1.eth)), // fee in third asset
      /** SELL, availableForSpending > required by spendable asset  */
      (SELL, 123.waves, 3.usd, Waves, amtMap(500.waves, 500.usd, 50.eth), amtMap(124.waves)),                 // fee in spent asset (123 + 1)
      (SELL, 123.waves, 3.usd, usd,   amtMap(500.waves, 500.usd, 50.eth), amtMap(123.waves, 1.usd)),          // fee in received asset
      (SELL, 0.1.waves, 3.usd, usd,   amtMap(500.waves, 500.usd, 50.eth), amtMap(0.1.waves, 1.usd)),          // fee in received asset, received amount < fee
      (SELL, 123.waves, 3.usd, eth,   amtMap(500.waves, 500.usd, 50.eth), amtMap(123.waves, ethAmt = 1.eth)), // fee in third asset
      /**
        * BUY, availableForSpending < required by spendable asset
        * Note:
        *  - (BUY, 0.1.waves, 3.usd, usd,   amtMap(500.waves, 0.9.usd, 50.eth))  - required 1.usd (marketOrderVolume = 0, only fee required),   balance = 0.9.usd,   received amount = 0.0.usd,   BalanceNotEnough by USD
        *  - (BUY, 0.1.waves, 3.usd, Waves, amtMap(0.8.waves, 500.usd, 50.eth))  - required 1.waves (marketOrderVolume = 0, only fee required), balance = 0.8.waves, received amount = 0.1.waves, BalanceNotEnough by WAVES
        *  - (BUY, 123.waves, 3.usd, eth,   amtMap(500.waves, 500.usd, 0.9.eth)) - required 1.eth,                                              balance = 0.9.eth,   received amount = 0.0.eth,   BalanceNotEnough by ETH
        */
      (BUY, 123.waves, 3.usd, usd,   amtMap(500.waves, 300.usd,  50.eth), amtMap(usdAmt = 300.usd)),  // fee in spent asset
      (BUY, 123.waves, 3.usd, Waves, amtMap(500.waves, 300.usd,  50.eth), amtMap(1.waves, 300.usd)),  // fee in received asset
      (BUY, 0.1.waves, 3.usd, Waves, amtMap(500.waves, 0.15.usd, 50.eth), amtMap(1.waves, 0.15.usd)), // fee in received asset, received amount < fee
      /**
        * SELL, availableForSpending < required by spendable asset
        * Note:
        *  - (SELL, 0.1.waves, 3.usd, Waves, amtMap(0.9.waves, 500.usd, 50.eth))  - required 1.waves (marketOrderVolume = 0, only fee required), balance = 0.9.waves, received amount = 0.0.waves, BalanceNotEnough by WAVES
        *  - (SELL, 0.1.waves, 3.usd, usd,   amtMap(500.waves, 0.6.usd, 50.eth))  - required 1.usd (marketOrderVolume = 0, only fee required),   balance = 0.6.usd,   received amount = 0.3.usd,   BalanceNotEnough by USD
        *  - (SELL, 123.waves, 3.usd, eth,   amtMap(500.waves, 500.usd, 0.9.eth)) - required 1.eth,                                              balance = 0.9.eth,   received amount = 0.0.eth,   BalanceNotEnough by ETH
        */
      (SELL, 123.waves, 3.usd, Waves, amtMap(100.waves,  500.usd, 50.eth), amtMap(100.waves)),        // fee in spent asset
      (SELL, 123.waves, 3.usd, usd,   amtMap(100.waves,  500.usd, 50.eth), amtMap(100.waves, 1.usd)), // fee in received asset
      (SELL, 0.1.waves, 3.usd, usd,   amtMap(0.05.waves, 500.usd, 50.eth), amtMap(0.05.waves, 1.usd)) // fee in received asset, received amount < fee
      // format: on
    )
  ) { (orderType: OrderType, amount: Long, price: Long, feeAsset: Asset, balance: Map[Asset, Long], reserves: Map[Asset, Long]) =>
    property {
      s"Reserves of the market order with no counters should be correct: ${marketOrderInfo(orderType, amount, price, feeAsset, balance)}"
    } {

      val tp = TestProbe()
      val addressDir = addressDirWithSpendableBalance(balance, testProbe = tp)
      val fee = Some(feeAsset.amt(matcherFee))

      val order = orderType match {
        case BUY => rawBuy(wavesUsdPair, amount, price, version = 3, feeAsset = feeAsset, matcherFee = fee)
        case SELL => rawSell(wavesUsdPair, amount, price, version = 3, feeAsset = feeAsset, matcherFee = fee)
      }
      initAddressesOf(order)

      def reservedBalanceBy(asset: Asset): Long = openVolume(order.senderPublicKey, asset, addressDir)

      val marketOrder = MarketOrder(order, balance)
      val expectedSpentAssetReserve = reserves(marketOrder.spentAsset)
      val expectedReceiveAssetReserve = reserves(marketOrder.rcvAsset)
      val expectedFeeAssetReserve = reserves(marketOrder.feeAsset)

      placeMarketOrder(tp, addressDir, marketOrder)
      val validated = tp.expectMsgType[ValidatedCommand.PlaceMarketOrder]
      validated should matchTo(ValidatedCommand.PlaceMarketOrder(marketOrder))

      addressDir ! AddressActor.Command.ApplyOrderBookAdded(OrderAdded(
        validated.marketOrder,
        reason = OrderAddedReason.RequestExecuted,
        timestamp = marketOrder.order.timestamp
      ))

      withClue {
        s"Place market $orderType order, fee in ${feeAsset.toStringSRT(orderType)} asset, " +
        s"expected reserves (spent/received/fee) = $expectedSpentAssetReserve/$expectedReceiveAssetReserve/$expectedFeeAssetReserve:\n"
      } {
        reservedBalanceBy(marketOrder.spentAsset) shouldBe expectedSpentAssetReserve
        reservedBalanceBy(marketOrder.rcvAsset) shouldBe expectedReceiveAssetReserve
        reservedBalanceBy(marketOrder.feeAsset) shouldBe expectedFeeAssetReserve
      }

      systemCancelMarketOrder(addressDir, marketOrder)

      withClue(s"System cancel of $orderType market order:\n") {
        reservedBalanceBy(marketOrder.spentAsset) shouldBe 0
        reservedBalanceBy(marketOrder.rcvAsset) shouldBe 0
        reservedBalanceBy(marketOrder.feeAsset) shouldBe 0
      }
    }
  }

  // noinspection ScalaStyle
  forAll(
    Table(
      /** NOTE! Fee = 1 fee asset */
      // format: off
      ("mo type", "mo amount", "mo price", "mo fee asset", "spendable balance", "lo amount", "lo price", "reserves map after execution"),
      /** r              = required,
        * f              = fee,
        * ea             = executed amount,
        * eap            = executed amount of price asset,
        * ef             = executed fee,
        * afs            = available for spending,
        * ea*, ef*, eap* = calculated by the formula AcceptedOrder.executedAmount */
      /** market BUY order PARTIALLY filled, available for spending > required by spendable asset */
      (BUY, 123.waves, 3.usd, usd,   amtMap(500.waves, 500.usd, 50.eth), 100.waves, 2.usd, amtMap(usdAmt = 169.19.usd)),                       // fee in spent asset,    USD: 123 * 3 [r] + 1 [f] - 100 * 2 [eap] - 100/123 [ef]
      (BUY, 123.waves, 3.usd, Waves, amtMap(500.waves, 500.usd, 50.eth), 100.waves, 2.usd, amtMap(0.18699187.waves, 169.usd)),                 // fee in received asset, USD: 123 * 3 [r] - 100 * 2 [eap], Waves: 1 [f] - 100/123 [ef]
      (BUY, 123.waves, 3.usd, eth,   amtMap(500.waves, 500.usd, 50.eth), 100.waves, 2.usd, amtMap(usdAmt = 169.usd, ethAmt = 0.18699187.eth)), // fee in third asset,    USD: 123 * 3 [r] - 100 * 2 [eap], ETH: 1 [f] - 100/123 [ef]
      /** market BUY order filled, available for spending > required by spendable asset */
      (BUY, 100.waves, 3.usd, usd,   amtMap(500.waves, 500.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in spent asset
      (BUY, 100.waves, 3.usd, Waves, amtMap(500.waves, 500.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in received asset
      (BUY, 100.waves, 3.usd, eth,   amtMap(500.waves, 500.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in third asset
      /** market SELL order PARTIALLY filled, available for spending > required by spendable asset */
      (SELL, 123.waves, 2.usd, Waves, amtMap(500.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(23.18699187.waves)),                 // fee in spent asset,    Waves: 123 [r] + 1 [f] - 100 [ea] - 100/123 [ef]
      (SELL, 123.waves, 2.usd, usd,   amtMap(500.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(23.waves, 0.19.usd)),                // fee in received asset, Waves: 123 [r] - 100 [ea], USD: 1 [f] - 100/123 [ef]
      (SELL, 123.waves, 2.usd, eth,   amtMap(500.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(23.waves, ethAmt = 0.18699187.eth)), // fee in third asset,    Waves: 123 [r] - 100 [ea], ETH: 1 [f] - 100/123 [ef]
      /** market SELL order filled, available for spending > required by spendable asset */
      (SELL, 100.waves, 2.usd, Waves, amtMap(500.waves, 500.usd, 50.eth), 200.waves, 3.usd, amtMap()), // fee in spent asset
      (SELL, 100.waves, 2.usd, usd,   amtMap(500.waves, 500.usd, 50.eth), 200.waves, 3.usd, amtMap()), // fee in received asset
      (SELL, 100.waves, 2.usd, eth,   amtMap(500.waves, 500.usd, 50.eth), 200.waves, 3.usd, amtMap()), // fee in third asset
      /** market BUY order PARTIALLY filled, available for spending < required by spendable asset, but is enough to cover market cost and fee */
      (BUY, 123.waves, 3.usd, usd,   amtMap(500.waves, 300.usd, 50.eth), 100.waves, 2.usd, amtMap(usdAmt = 99.19.usd)),                        // fee in spent asset,    USD: 300 [afs] - 100 * 2 [eap] - 100/123 [ef]
      (BUY, 123.waves, 3.usd, Waves, amtMap(500.waves, 300.usd, 50.eth), 100.waves, 2.usd, amtMap(0.18699187.waves, 100.usd)),                 // fee in received asset, USD: 300 [afs] - 100 * 2 [eap], Waves: 1 [f] - 100/123 [ef]
      (BUY, 123.waves, 3.usd, eth,   amtMap(500.waves, 300.usd, 50.eth), 100.waves, 2.usd, amtMap(usdAmt = 100.usd, ethAmt = 0.18699187.eth)), // fee in third asset,    USD: 300 [afs] - 100 * 2 [eap], ETH: 1 [f] - 100/123 [ef]
      /** market BUY order PARTIALLY filled, available for spending < required by spendable asset and is NOT enough to cover market cost and fee */
      (BUY, 100.waves, 3.usd, usd,   amtMap(500.waves, 300.usd, 50.eth), 100.waves, 3.usd, amtMap(usdAmt = 0.01.usd)),                          // fee in spent asset,    USD: 300 [afs] - 299.00 [eap*] - 0.99 [ef*]
      (BUY, 100.waves, 3.usd, usd,   amtMap(500.waves, 290.usd, 50.eth), 100.waves, 3.usd, amtMap(usdAmt = 0.01.usd)),                          // fee in spent asset,    USD: 290 [afs] - 289.03 [eap*] - 0.96 [ef*]
      (BUY, 100.waves, 3.usd, Waves, amtMap(500.waves, 290.usd, 50.eth), 100.waves, 3.usd, amtMap(0.03336667.waves, 0.01.usd)),                 // fee in received asset, USD: 290 [afs] - 289.99 [eap*], Waves: 1 [f] - 96.66333334 [ea*]
      (BUY, 100.waves, 3.usd, eth,   amtMap(500.waves, 290.usd, 50.eth), 100.waves, 3.usd, amtMap(usdAmt = 0.01.usd, ethAmt = 0.03336667.eth)), // fee in third asset,    USD: 290 [afs] - 289.99 [eap*], ETH = 1 [f] - 0.96663333 [ef*]
      /** market BUY order filled, available for spending = required by spendable asset */
      (BUY, 100.waves, 3.usd, usd,   amtMap(500.waves, 301.usd, 50.eth), 100.waves, 3.usd, amtMap()), // fee in spent asset
      (BUY, 100.waves, 3.usd, Waves, amtMap(500.waves, 300.usd, 50.eth), 100.waves, 3.usd, amtMap()), // fee in received asset
      (BUY, 100.waves, 3.usd, eth,   amtMap(500.waves, 300.usd, 50.eth), 100.waves, 3.usd, amtMap()), // fee in third asset
      /** market BUY order filled, available for spending < required by spendable asset */
      (BUY, 100.waves, 3.usd, usd,   amtMap(500.waves, 250.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in spent asset
      (BUY, 100.waves, 3.usd, Waves, amtMap(500.waves, 250.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in received asset
      (BUY, 100.waves, 3.usd, eth,   amtMap(500.waves, 250.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in third asset
      /** market SELL order PARTIALLY filled, available for spending < required by spendable asset but is enough to cover market amount and fee */
      (SELL, 123.waves, 2.usd, Waves, amtMap(110.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(9.18699187.waves)),                  // fee in spent asset,    Waves: 110 [afs] - 100 [ea] - 100/123 [ef]
      (SELL, 123.waves, 2.usd, usd,   amtMap(110.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(10.waves, 0.19.usd)),                // fee in received asset, Waves: 110 [afs] - 100 [ea], USD: 1 [f] - 100/123 [ef]
      (SELL, 123.waves, 2.usd, eth,   amtMap(110.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(10.waves, ethAmt = 0.18699187.eth)), // fee in third asset,    Waves: 110 [afs] - 100 [ea], USD: 1 [f] - 100/123 [ef]
      /** market SELL order PARTIALLY filled, available for spending < required by spendable asset and NOT enough to cover market amount and fee */
      (SELL, 123.waves, 2.usd, Waves, amtMap(100.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(0.00000001.waves)),        // fee in spent asset,    Waves: 100 [afs] - 99.19354838 [ea*] - 0.80645161 [ef*]
      (SELL, 123.waves, 2.usd, Waves, amtMap(90.waves, 500.usd, 50.eth),  100.waves, 3.usd, amtMap(0.00000001.waves)),        // fee in spent asset,    Waves:  90 [afs] - 89.27419354 [ea*] - 0.72580645 [ef*]
      (SELL, 123.waves, 2.usd, usd,   amtMap(90.waves, 500.usd, 50.eth),  100.waves, 3.usd, amtMap(usdAmt = 0.27.usd)),       // fee in received asset, USD: 1 [f] - 90/123 [ef]
      (SELL, 123.waves, 2.usd, eth,   amtMap(90.waves, 500.usd, 50.eth),  100.waves, 3.usd, amtMap(ethAmt = 0.26829269.eth)), // fee in third asset,    ETH: 1 [f] - 90/123 [ef]
      /** market SELL order filled, available for spending = required by spendable asset */
      (SELL, 100.waves, 3.usd, Waves, amtMap(101.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap()), // fee in spent asset
      (SELL, 100.waves, 3.usd, usd,   amtMap(100.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap()), // fee in received asset
      (SELL, 100.waves, 3.usd, eth,   amtMap(100.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap()) // fee in third asset
      /** market SELL order filled, available for spending < required by spendable asset - impossible case */
      // format: on
    )
  ) {
    (
      moTpe: OrderType,
      moAmt: Long,
      moPrc: Long,
      moFeeAsst: Asset,
      balance: Map[Asset, Long],
      loAmt: Long,
      loPrc: Long,
      reserves: Map[Asset, Long]
    ) =>
      property {
        s"Reserves of the market order (${marketOrderInfo(moTpe, moAmt, moPrc, moFeeAsst, balance)}) executed with the counter order (${limitOrderInfo(moTpe.opposite, loAmt, loPrc)}) should be correct"
      } {

        val tp = TestProbe()
        val addressDir = addressDirWithSpendableBalance(balance, tp)
        val fee = Some(moFeeAsst.amt(matcherFee))

        val (order, counter) = moTpe match {
          case BUY =>
            rawBuy(wavesUsdPair, moAmt, moPrc, version = 3, feeAsset = moFeeAsst, matcherFee = fee) -> rawSell(wavesUsdPair, loAmt, loPrc)
          case SELL =>
            rawSell(wavesUsdPair, moAmt, moPrc, version = 3, feeAsset = moFeeAsst, matcherFee = fee) -> rawBuy(wavesUsdPair, loAmt, loPrc)
        }
        initAddressesOf(counter, order)

        def reservedBalanceBy(asset: Asset): Long = openVolume(order.senderPublicKey, asset, addressDir)

        val marketOrder = MarketOrder(order, balance)

        placeMarketOrder(tp, addressDir, marketOrder)
        tp.expectMsgType[ValidatedCommand.PlaceMarketOrder]

        val orderExecutedEvent = executeMarketOrder(addressDir, marketOrder, LimitOrder(counter))

        val expectedSpentAssetReserve = reserves(marketOrder.spentAsset)
        val expectedReceiveAssetReserve = reserves(marketOrder.rcvAsset)
        val expectedFeeAssetReserve = reserves(marketOrder.feeAsset)

        withClue {
          s"Execution:\n" +
          s"MARKET $moTpe ($moAmt ${wavesUsdPair.amountAsset.toStringWUE} @ $moPrc ${wavesUsdPair.priceAsset.toStringWUE}, " +
          s"fee = ${moFeeAsst.amt(matcherFee)} ${moFeeAsst.toStringWUE}, " +
          s"afs = ${marketOrder.availableForSpending} ${marketOrder.spentAsset.toStringWUE}),\n" +
          s"LIMIT ${moTpe.opposite} ($loAmt ${wavesUsdPair.amountAsset.toStringWUE} @ $loPrc ${wavesUsdPair.priceAsset.toStringWUE}),\n" +
          s"expected reserves after execution (spent/received/fee) = " +
          s"$expectedSpentAssetReserve/$expectedReceiveAssetReserve/$expectedFeeAssetReserve:\n"
        } {
          reservedBalanceBy(marketOrder.spentAsset) shouldBe expectedSpentAssetReserve
          reservedBalanceBy(marketOrder.rcvAsset) shouldBe expectedReceiveAssetReserve
          reservedBalanceBy(marketOrder.feeAsset) shouldBe expectedFeeAssetReserve
        }

        systemCancelMarketOrder(addressDir, orderExecutedEvent.submittedMarketRemaining(marketOrder))

        withClue(s"System cancel of $moTpe market order remaining:\n") {
          reservedBalanceBy(marketOrder.spentAsset) shouldBe 0
          reservedBalanceBy(marketOrder.rcvAsset) shouldBe 0
          reservedBalanceBy(marketOrder.feeAsset) shouldBe 0
        }
      }
  }

  private def initAddressesOf(orders: Order*): Unit =
    orders.map(_.sender.toAddress).foreach { address =>
      addressDir ! AddressDirectoryActor.Command.ForwardMessage(
        address,
        AddressActor.Command.SetInitialBalances(Success(AddressBalanceUpdates.empty), 0)
      )
    }

}
